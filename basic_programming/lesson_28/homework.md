
1. **Интерфейсы:**

    **Задание:** Создайте интерфейсы `Flying` и `Living`. `Flying` должен содержать методы: `takeOff()`, `land()`, `fly()`. `Living` должен содержать методы: `eat()`, `sleep()`, и `breath()`. Создайте класс `Bird`, который реализует оба интерфейса. Затем создайте классы `Eagle` и `Penguin` на основе `Bird`, у каждого из которых должны быть свои реализации вышеупомянутых методов.

2. **Наследование:**

    **Задание:** Создайте абстрактный класс `Shape` с атрибутами `color` и абстрактными методами `area()` и `perimeter()`. Реализуйте подклассы `Circle`, `Rectangle` и `Triangle`, которые наследуются от `Shape` и имеют свои реализации методов `area()` и `perimeter()`. Учтите различные атрибуты каждой фигуры, такие как радиус для круга и стороны для прямоугольника и треугольника.

3. **Инкапсуляция:**

    **Задание:** Создайте класс `BankAccount` с частными атрибутами: `accountNumber`, `balance` и `pinCode`. Обеспечьте доступ к `balance` через публичные методы `deposit()`, `withdraw()`, и `checkBalance()`. Однако, при попытке выполнить операцию `withdraw()`, необходимо запросить `pinCode` для проверки. Если `pinCode` неверен, не дайте выполнить операцию.


4. **Задание:** 
	Создайте интерфейс `Storage`, который содержит методы `store()`, `retrieve()` и `count()`. Затем создайте два класса, которые реализуют этот интерфейс:

1. **FileStorage:** Этот класс должен имитировать хранение данных в файлах. У него должны быть следующие атрибуты: `capacity` (вместимость хранилища) и `itemsStored` (список хранимых элементов). Метод `store()` должен добавлять элемент в `itemsStored`, если есть свободное место, иначе выводить сообщение об ошибке. Метод `retrieve()` должен извлекать элемент из `itemsStored` по индексу или ключу. Метод `count()` должен возвращать количество элементов в `itemsStored`.

2. **MemoryStorage:** Этот класс должен имитировать хранение данных в оперативной памяти. Он также имеет атрибуты `capacity` и `itemsStored`. Однако, вы можете добавить дополнительные ограничения или функции, например, автоматическое удаление наименее используемых элементов при переполнении.
